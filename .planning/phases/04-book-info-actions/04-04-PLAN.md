---
phase: 04-book-info-actions
plan: 04
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - iosApp/iosApp/BookFeedView.swift
  - androidApp/src/main/java/com/browsy/android/ui/feed/BookFeedScreen.kt
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "First book tap shows info sheet with content (not blank)"
    - "TBR state syncs from detail sheet back to feed heart icon"
    - "Android app displays loading spinner during initial load"
    - "Android app shows error state if API call fails"
  artifacts:
    - path: "iosApp/iosApp/BookFeedView.swift"
      provides: "Fixed sheet binding using .sheet(item:) and onDismiss reload"
    - path: "androidApp/src/main/java/com/browsy/android/ui/feed/BookFeedScreen.kt"
      provides: "Loading spinner and error state UI"
  key_links:
    - from: "BookFeedView.sheet"
      to: "BookInfoSheet"
      via: ".sheet(item:) binding"
      pattern: "\\.sheet\\(item:"
    - from: "BookFeedView.sheet.onDismiss"
      to: "BookCoverCard.shelfViewModel"
      via: "reload callback"
      pattern: "onDismiss.*loadState"
---

<objective>
Fix three UAT-identified bugs in iOS and Android book info functionality.

Purpose: Close gaps found during user acceptance testing:
1. iOS blank sheet on first tap (race condition with .sheet(isPresented:))
2. iOS TBR state not syncing from detail sheet to feed (separate ViewModels)
3. Android stuck on loading screen (missing loading/error UI states)

Output: Working book info flow on both platforms with proper state sync.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# UAT with diagnosed issues
@.planning/phases/04-book-info-actions/04-UAT.md

# Current implementations
@iosApp/iosApp/BookFeedView.swift
@iosApp/iosApp/BookInfoSheet.swift
@iosApp/iosApp/ShelfViewModel.swift
@androidApp/src/main/java/com/browsy/android/ui/feed/BookFeedScreen.kt
@androidApp/src/main/java/com/browsy/android/ui/feed/FeedViewModel.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix iOS blank sheet with .sheet(item:) binding</name>
  <files>iosApp/iosApp/BookFeedView.swift</files>
  <action>
    The issue: Using `.sheet(isPresented:)` with a separate `selectedBook` state variable creates a race condition. The sheet can start rendering before `selectedBook` is set, causing the `if let book = selectedBook` check to fail and show empty content.

    The fix: Use `.sheet(item:)` which binds presentation directly to the optional Book. The sheet only presents when the item is non-nil, and the book is passed directly to the content closure.

    Changes to BookFeedView:

    1. Remove the `showingInfo` state variable - no longer needed:
    ```swift
    // REMOVE: @State private var showingInfo: Bool = false
    // KEEP: @State private var selectedBook: Book? = nil
    ```

    2. Update the tap gesture to only set selectedBook:
    ```swift
    .onTapGesture {
        selectedBook = book
        // REMOVE: showingInfo = true
    }
    ```

    3. Replace `.sheet(isPresented:)` with `.sheet(item:)`:
    ```swift
    .sheet(item: $selectedBook) { book in
        BookInfoSheet(book: book)
            .presentationDetents([.medium, .large])
            .presentationDragIndicator(.visible)
    }
    ```

    Note: For `.sheet(item:)` to work, Book must conform to Identifiable. The shared Kotlin Book class exposes `id` property, but Swift needs explicit conformance. Add an extension at the bottom of BookFeedView.swift:

    ```swift
    extension Book: Identifiable {}
    ```

    This works because Book already has an `id` property of type String, which satisfies Identifiable's requirement.
  </action>
  <verify>Xcode build succeeds: xcodebuild -project iosApp/iosApp.xcodeproj -scheme iosApp -destination 'platform=iOS Simulator,name=iPhone 15' build 2>&1 | tail -20</verify>
  <done>First book tap shows info sheet with content, not blank white sheet</done>
</task>

<task type="auto">
  <name>Task 2: Fix iOS TBR state sync with onDismiss callback</name>
  <files>iosApp/iosApp/BookFeedView.swift</files>
  <action>
    The issue: BookCoverCard and BookInfoSheet each create their own @StateObject ShelfViewModel instances. When TBR is toggled in the detail sheet, it updates the repository, but the feed's ShelfViewModel never reloads its state.

    The fix: Add an onDismiss callback to the sheet that tells the BookCoverCard to reload its shelf state. Since we're using `.sheet(item:)`, we need to track which book's card needs reloading.

    Changes to BookFeedView:

    1. Add state to track the book ID that needs refresh after sheet dismisses:
    ```swift
    @State private var bookIdToRefresh: String? = nil
    ```

    2. Before presenting the sheet, store the book ID:
    ```swift
    .onTapGesture {
        bookIdToRefresh = book.id
        selectedBook = book
    }
    ```

    3. Update BookCoverCard to accept an optional refresh trigger and reload when it matches:
    Pass a binding or trigger value to BookCoverCard:
    ```swift
    BookCoverCard(book: book, index: index, viewModel: viewModel, refreshTrigger: bookIdToRefresh == book.id ? bookIdToRefresh : nil)
    ```

    4. Update BookCoverCard struct to accept refreshTrigger:
    ```swift
    struct BookCoverCard: View {
        let book: Book
        let index: Int
        let viewModel: FeedViewModel
        var refreshTrigger: String? = nil
        @StateObject private var shelfViewModel = ShelfViewModel()

        // ... existing body ...
    }
    ```

    5. Add .onChange to BookCoverCard to reload when refreshTrigger changes:
    ```swift
    .onChange(of: refreshTrigger) { oldValue, newValue in
        if newValue != nil {
            shelfViewModel.loadState(for: book.id)
        }
    }
    ```

    6. Add onDismiss to the sheet that clears selectedBook (which triggers the refresh):
    ```swift
    .sheet(item: $selectedBook, onDismiss: {
        // Trigger refresh by briefly keeping bookIdToRefresh then clearing
        // The onChange in BookCoverCard will pick this up
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            bookIdToRefresh = nil
        }
    }) { book in
        BookInfoSheet(book: book)
            .presentationDetents([.medium, .large])
            .presentationDragIndicator(.visible)
    }
    ```

    Alternative simpler approach - use NotificationCenter or a shared reload counter:

    Actually, the simplest fix is to make the sheet's onDismiss callback directly reload the card's state. Since we know which book was shown, we can pass a reload trigger:

    Simpler approach - just reload state when card appears again:

    The cleanest fix: Instead of complex state passing, use the `.onAppear` modifier that already exists on BookCoverCard. The card already calls `shelfViewModel.loadState(for: book.id)` in onAppear. The issue is onAppear doesn't fire when returning from sheet.

    Use `.onChange(of: selectedBook)` at the BookCoverCard level to reload when sheet dismisses:

    In BookCoverCard, add:
    ```swift
    .onChange(of: selectedBook) { oldValue, newValue in
        // When selectedBook becomes nil (sheet dismissed), reload state
        if newValue == nil {
            shelfViewModel.loadState(for: book.id)
        }
    }
    ```

    But BookCoverCard doesn't have access to selectedBook. Pass it as a binding.

    Final recommended approach:

    1. In BookFeedView, pass selectedBook as an optional binding to BookCoverCard:
    ```swift
    BookCoverCard(book: book, index: index, viewModel: viewModel, sheetDismissed: selectedBook == nil)
    ```

    2. Update BookCoverCard:
    ```swift
    struct BookCoverCard: View {
        let book: Book
        let index: Int
        let viewModel: FeedViewModel
        let sheetDismissed: Bool
        @StateObject private var shelfViewModel = ShelfViewModel()

        // In body, add:
        .onChange(of: sheetDismissed) { oldValue, newValue in
            if newValue {
                shelfViewModel.loadState(for: book.id)
            }
        }
    }
    ```

    This ensures that when the sheet dismisses (selectedBook becomes nil, sheetDismissed becomes true), all visible cards reload their shelf state.
  </action>
  <verify>Xcode build succeeds</verify>
  <done>TBR toggled in detail sheet immediately reflects in feed heart icon after dismissing sheet</done>
</task>

<task type="auto">
  <name>Task 3: Fix Android loading state UI</name>
  <files>androidApp/src/main/java/com/browsy/android/ui/feed/BookFeedScreen.kt</files>
  <action>
    The issue: BookFeedScreen has a logical gap in the conditional rendering. When `isLoading=true` AND `books.isEmpty()`, no UI is shown. The current code:
    - Shows "Loading books..." text only when `books.isEmpty() && !isLoading` (after loading finishes with empty result)
    - Shows VerticalPager only when `books.isNotEmpty()`
    - Shows NOTHING when `isLoading=true && books.isEmpty()` (initial load state)

    The fix: Add proper loading spinner for initial load state, and error state UI.

    Changes to BookFeedScreen:

    1. Add error state to FeedViewModel exposure (or handle in UI). For now, add UI-level error detection.

    2. Restructure the conditional rendering in BookFeedScreen:
    ```kotlin
    Box(modifier = Modifier.fillMaxSize()) {
        when {
            // Initial loading state - show spinner
            isLoading && books.isEmpty() -> {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally
                    ) {
                        CircularProgressIndicator()
                        Spacer(modifier = Modifier.height(16.dp))
                        Text(
                            text = "Loading books...",
                            style = MaterialTheme.typography.bodyLarge,
                            color = MaterialTheme.colorScheme.onBackground
                        )
                    }
                }
            }

            // Empty state after loading - show error/retry
            !isLoading && books.isEmpty() -> {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally
                    ) {
                        Icon(
                            imageVector = Icons.Default.Warning,
                            contentDescription = "Error",
                            modifier = Modifier.size(48.dp),
                            tint = MaterialTheme.colorScheme.error
                        )
                        Spacer(modifier = Modifier.height(16.dp))
                        Text(
                            text = "Unable to load books",
                            style = MaterialTheme.typography.bodyLarge,
                            color = MaterialTheme.colorScheme.onBackground
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                        Text(
                            text = "Check your internet connection",
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }
            }

            // Normal state - show pager
            books.isNotEmpty() -> {
                VerticalPager(
                    state = pagerState,
                    pageSpacing = 0.dp,
                    key = { books[it].id },
                    modifier = Modifier.fillMaxSize(),
                    pageContent = { page ->
                        BookCoverPage(
                            book = books[page],
                            onBookClick = {
                                selectedBook = books[page]
                                showInfoSheet = true
                            },
                            modifier = Modifier.fillMaxSize()
                        )
                    }
                )
            }
        }

        // Book info bottom sheet (outside the when block, always available)
        if (showInfoSheet && selectedBook != null) {
            BookInfoBottomSheet(
                book = selectedBook!!,
                onDismiss = {
                    showInfoSheet = false
                    selectedBook = null
                }
            )
        }
    }
    ```

    3. Add required imports:
    ```kotlin
    import androidx.compose.material3.CircularProgressIndicator
    import androidx.compose.material.icons.filled.Warning
    import androidx.compose.foundation.layout.size
    import androidx.compose.ui.unit.dp
    ```

    Note: The Icon import for Warning may need adjustment. Use:
    ```kotlin
    import androidx.compose.material.icons.Icons
    import androidx.compose.material.icons.filled.Warning
    ```

    If Warning icon is not available in material.icons.filled, use an alternative like:
    ```kotlin
    import androidx.compose.material.icons.outlined.CloudOff
    ```
    Or simply use Text-based error indicator.
  </action>
  <verify>./gradlew :androidApp:assembleDebug completes without errors</verify>
  <done>Android shows loading spinner during initial load, error state if API fails</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] iOS Xcode build succeeds
- [ ] Android Gradle build succeeds
- [ ] iOS: Tapping first book shows info sheet with content (not blank)
- [ ] iOS: Toggling TBR in sheet updates feed heart icon after dismiss
- [ ] Android: Loading spinner visible during initial API call
- [ ] Android: Error state shown if books fail to load
</verification>

<success_criteria>

- All three UAT gaps closed
- No regressions in existing functionality
- Both platforms build successfully
</success_criteria>

<output>
After completion, create `.planning/phases/04-book-info-actions/04-04-SUMMARY.md`
</output>
