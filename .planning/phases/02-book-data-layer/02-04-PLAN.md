---
phase: 02-book-data-layer
plan: 04
type: execute
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - shared/src/commonMain/kotlin/com/browsy/data/repository/BookRepository.kt
  - shared/src/commonMain/kotlin/com/browsy/data/cache/BookCache.kt
autonomous: true
---

<objective>
Implement BookRepository with dual-API fallback strategy and in-memory caching.

Purpose: Unified book data access layer that tries Google Books first, falls back to Open Library, and caches results
Output: BookRepository providing reliable book search with automatic fallback and performance optimization
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-book-data-layer/DISCOVERY.md
@.planning/phases/02-book-data-layer/02-01-SUMMARY.md
@.planning/phases/02-book-data-layer/02-02-SUMMARY.md
@.planning/phases/02-book-data-layer/02-03-SUMMARY.md

# API clients from Plans 02 and 03:
@shared/src/commonMain/kotlin/com/browsy/data/remote/GoogleBooksApi.kt
@shared/src/commonMain/kotlin/com/browsy/data/remote/OpenLibraryApi.kt

# Mappers:
@shared/src/commonMain/kotlin/com/browsy/data/remote/mapper/GoogleBooksMapper.kt
@shared/src/commonMain/kotlin/com/browsy/data/remote/mapper/OpenLibraryMapper.kt

# Data models:
@shared/src/commonMain/kotlin/com/browsy/data/model/Book.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create in-memory book cache</name>
  <files>shared/src/commonMain/kotlin/com/browsy/data/cache/BookCache.kt</files>
  <action>
Create BookCache class in com.browsy.data.cache package with LRU eviction:

```kotlin
class BookCache(private val maxSize: Int = 100) {
    private val cache = mutableMapOf&lt;String, CachedBook&gt;()
    private val accessOrder = mutableListOf&lt;String&gt;()

    fun get(key: String): Book? {
        val cached = cache[key] ?: return null

        // Check if expired (30 minutes TTL)
        if (System.currentTimeMillis() - cached.timestamp > 30 * 60 * 1000) {
            remove(key)
            return null
        }

        // Update access order (LRU)
        accessOrder.remove(key)
        accessOrder.add(key)

        return cached.book
    }

    fun put(key: String, book: Book) {
        if (cache.size >= maxSize &amp;&amp; key !in cache) {
            // Evict least recently used
            val lru = accessOrder.removeFirstOrNull()
            lru?.let { cache.remove(it) }
        }

        cache[key] = CachedBook(book, System.currentTimeMillis())
        accessOrder.remove(key)
        accessOrder.add(key)
    }

    fun remove(key: String) {
        cache.remove(key)
        accessOrder.remove(key)
    }

    fun clear() {
        cache.clear()
        accessOrder.clear()
    }

    private data class CachedBook(
        val book: Book,
        val timestamp: Long
    )
}
```

30-minute TTL to balance freshness and performance.
LRU eviction when cache is full.
Add KDoc explaining cache strategy and eviction policy.
  </action>
  <verify>./gradlew :shared:build compiles cache successfully</verify>
  <done>BookCache provides LRU in-memory caching with 30-minute TTL</done>
</task>

<task type="auto">
  <name>Task 2: Create BookRepository with dual-API strategy</name>
  <files>shared/src/commonMain/kotlin/com/browsy/data/repository/BookRepository.kt</files>
  <action>
Create BookRepository class in com.browsy.data.repository package:

```kotlin
class BookRepository(
    private val googleBooksApi: GoogleBooksApi,
    private val openLibraryApi: OpenLibraryApi,
    private val cache: BookCache = BookCache()
) {
    suspend fun searchBooks(query: String): Result&lt;List&lt;Book&gt;&gt; {
        // Check cache first
        val cacheKey = "search:$query"
        cache.get(cacheKey)?.let { return Result.success(listOf(it)) }

        // Try Google Books first
        val googleResult = googleBooksApi.searchBooks(query)
        if (googleResult.isSuccess) {
            val books = googleResult.getOrNull()?.items?.map {
                GoogleBooksMapper.run { it.toBook() }
            }.orEmpty()

            if (books.isNotEmpty()) {
                books.firstOrNull()?.let { cache.put(cacheKey, it) }
                return Result.success(books)
            }
        }

        // Fallback to Open Library if Google Books failed or returned nothing
        // Open Library doesn't have general search, only ISBN lookup
        // For MVP, return empty list if Google Books has nothing
        return Result.success(emptyList())
    }

    suspend fun getBookByIsbn(isbn: String): Result&lt;Book?&gt; {
        // Check cache
        val cacheKey = "isbn:$isbn"
        cache.get(cacheKey)?.let { return Result.success(it) }

        // Try Google Books first
        val googleResult = googleBooksApi.getBookByIsbn(isbn)
        if (googleResult.isSuccess) {
            val book = googleResult.getOrNull()?.items?.firstOrNull()?.let {
                GoogleBooksMapper.run { it.toBook() }
            }
            if (book != null) {
                cache.put(cacheKey, book)
                return Result.success(book)
            }
        }

        // Fallback to Open Library
        val openLibraryResult = openLibraryApi.getBookByIsbn(isbn)
        if (openLibraryResult.isSuccess) {
            val book = openLibraryResult.getOrNull()?.let {
                OpenLibraryMapper.run { it.toBook(isbn) }
            }
            if (book != null) {
                cache.put(cacheKey, book)
                return Result.success(book)
            }
        }

        // Neither API found the book
        return Result.success(null)
    }

    fun close() {
        googleBooksApi.close()
        openLibraryApi.close()
    }
}
```

Try Google Books first for better metadata quality.
Fall back to Open Library if Google Books fails or has no results.
Cache successful results to reduce API calls.
Use Result type for consistent error handling.
Add KDoc explaining dual-API strategy and caching behavior.
  </action>
  <verify>./gradlew :shared:build compiles repository successfully</verify>
  <done>BookRepository provides unified book access with automatic fallback and caching</done>
</task>

<task type="auto">
  <name>Task 3: Add repository initialization helper</name>
  <files>shared/src/commonMain/kotlin/com/browsy/data/repository/BookRepository.kt</files>
  <action>
Add companion object to BookRepository with factory method:

```kotlin
companion object {
    /**
     * Create BookRepository instance with default configuration.
     * Requires Google Books API key from environment/config.
     */
    fun create(googleBooksApiKey: String): BookRepository {
        return BookRepository(
            googleBooksApi = GoogleBooksApi(googleBooksApiKey),
            openLibraryApi = OpenLibraryApi(),
            cache = BookCache()
        )
    }
}
```

This provides a simple entry point for creating repositories.
Add KDoc explaining that API key should come from platform-specific configuration.
  </action>
  <verify>./gradlew :shared:build compiles with companion object</verify>
  <done>BookRepository.create() provides convenient initialization</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] ./gradlew :shared:build succeeds without errors
- [ ] BookCache implements LRU eviction and TTL expiration
- [ ] BookRepository tries Google Books first, then Open Library
- [ ] Search results and ISBN lookups are cached
- [ ] Repository uses Result type consistently
- [ ] No hardcoded API keys in repository code
</verification>

<success_criteria>
- All tasks completed
- BookCache provides in-memory caching with LRU eviction
- BookRepository integrates both APIs with fallback logic
- Cache reduces redundant API calls for same queries
- Factory method simplifies repository creation
- Phase 2 complete: Book data layer ready for UI integration
</success_criteria>

<output>
After completion, create `.planning/phases/02-book-data-layer/02-04-SUMMARY.md`
</output>
