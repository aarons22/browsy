---
phase: 05-backend-infrastructure
plan: 02
type: execute
wave: 2
depends_on: [05-01]
files_modified: [
  backend/src/services/bookService.ts,
  backend/src/controllers/shelfController.ts,
  backend/src/models/index.ts,
  backend/src/routes/shelves.ts,
  backend/src/middleware/validation.ts,
  backend/src/app.ts
]
autonomous: true

must_haves:
  truths:
    - "API accepts POST /api/shelves/:userId/books to add books to shelves"
    - "API returns GET /api/shelves/:userId to list user's shelves"
    - "Firestore stores user shelf data with proper structure"
  artifacts:
    - path: "backend/src/services/bookService.ts"
      provides: "Firestore operations for user shelves"
      exports: ["addBookToShelf", "getUserShelves"]
    - path: "backend/src/controllers/shelfController.ts"
      provides: "HTTP request handlers"
      exports: ["addBook", "getShelves"]
    - path: "backend/src/routes/shelves.ts"
      provides: "API route definitions"
      contains: "/api/shelves"
  key_links:
    - from: "backend/src/controllers/shelfController.ts"
      to: "backend/src/services/bookService.ts"
      via: "service layer calls"
      pattern: "bookService\\.(addBookToShelf|getUserShelves)"
    - from: "backend/src/routes/shelves.ts"
      to: "backend/src/controllers/shelfController.ts"
      via: "route handler mapping"
      pattern: "router\\.(get|post).*shelfController"
    - from: "backend/src/services/bookService.ts"
      to: "firestore database"
      via: "Firebase Admin SDK"
      pattern: "db\\.collection.*users"
---

<objective>
Implement Firestore integration and REST API endpoints for user book shelf operations.

Purpose: Create the data persistence layer and HTTP API that will sync user's TBR/Read/Recommend shelves with the mobile app's local storage.
Output: Working API endpoints that store and retrieve user shelf data in Firestore
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-backend-infrastructure/05-RESEARCH.md
@.planning/phases/05-backend-infrastructure/05-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Firebase Admin and Data Models</name>
  <files>
    backend/src/app.ts
    backend/src/models/index.ts
  </files>
  <action>
    Set up Firebase Admin SDK and TypeScript data models following research patterns:

    1. Update src/app.ts to initialize Firebase Admin:
       - Import { initializeApp, applicationDefault } from 'firebase-admin/app'
       - Import { getFirestore } from 'firebase-admin/firestore'
       - Initialize Firebase with applicationDefault() credentials
       - Export db instance for use in services
       - Add after existing middleware, before routes

    2. Create src/models/index.ts with data types:
       - Book interface matching mobile app's Book model (id, title, author, coverUrl, etc.)
       - UserShelf interface with name (TBR|Read|Recommendations), books: Book[], updatedAt: Date
       - Export all model types for use across backend

    Use research Firestore schema pattern: users/{userId}/shelves/{shelfType} documents.
    Ensure Book interface matches the mobile app's existing Book model from Phase 2.
  </action>
  <verify>cd backend && npm run build</verify>
  <done>Firebase Admin initializes successfully and TypeScript models compile without errors</done>
</task>

<task type="auto">
  <name>Task 2: Create Firestore Service Layer</name>
  <files>
    backend/src/services/bookService.ts
  </files>
  <action>
    Implement Firestore operations for user shelf management following research transaction patterns:

    1. Create src/services/bookService.ts with functions:
       - addBookToShelf(userId: string, shelfType: string, book: Book): Promise<void>
       - removeBookFromShelf(userId: string, shelfType: string, bookId: string): Promise<void>
       - getUserShelves(userId: string): Promise<UserShelf[]>
       - getShelfBooks(userId: string, shelfType: string): Promise<Book[]>

    2. Use Firestore transaction pattern from research for addBookToShelf:
       - Check if book already exists in shelf (prevent duplicates)
       - Update shelf document with new book in books array
       - Set updatedAt timestamp

    3. For getUserShelves, query users/{userId}/shelves collection and return all shelves
    4. Include proper error handling with try/catch and meaningful error messages
    5. Import db from ../app.ts and use getFirestore() connection

    Follow research code example patterns exactly for Firestore operations and transactions.
  </action>
  <verify>cd backend && npm run build</verify>
  <done>Firestore service functions compile and implement CRUD operations for user shelves</done>
</task>

<task type="auto">
  <name>Task 3: Create API Controllers and Routes</name>
  <files>
    backend/src/controllers/shelfController.ts
    backend/src/routes/shelves.ts
    backend/src/middleware/validation.ts
    backend/src/app.ts
  </files>
  <action>
    Create REST API endpoints following Express.js controller pattern from research:

    1. Create src/controllers/shelfController.ts with handlers:
       - addBook(req: Request, res: Response): POST /api/shelves/:userId/books
       - removeBook(req: Request, res: Response): DELETE /api/shelves/:userId/books/:bookId
       - getShelves(req: Request, res: Response): GET /api/shelves/:userId
       - getShelfBooks(req: Request, res: Response): GET /api/shelves/:userId/:shelfType

    2. Create src/middleware/validation.ts for request validation:
       - validateUserId: check userId parameter format
       - validateShelfType: ensure shelfType is TBR|Read|Recommendations
       - validateBook: ensure required book fields (id, title, author)

    3. Create src/routes/shelves.ts:
       - Define Express router with parameterized routes
       - Apply validation middleware to appropriate endpoints
       - Wire up controller functions

    4. Update src/app.ts to mount /api/shelves routes

    Use research error handling pattern - try/catch in controllers with 500 status for errors.
    Ensure API matches mobile app's existing shelf types (TBR, READ, RECOMMEND from Phase 4).
  </action>
  <verify>cd backend && npm start</verify>
  <done>API endpoints start successfully and accept HTTP requests with proper validation</done>
</task>

</tasks>

<verification>
- [ ] Firebase Admin SDK initializes without errors
- [ ] TypeScript models match mobile app's Book interface
- [ ] Firestore service layer handles CRUD operations with transactions
- [ ] API endpoints respond with appropriate status codes
- [ ] Request validation prevents malformed data
- [ ] curl -X GET http://localhost:8080/api/shelves/test-user returns JSON response
</verification>

<success_criteria>
- Firestore integration works for storing and retrieving user shelf data
- REST API endpoints accept mobile app data format
- Validation middleware prevents data corruption
- Service layer uses transactions for data consistency
- API matches mobile app's existing BookShelf types from Phase 4
</success_criteria>

<output>
After completion, create `.planning/phases/05-backend-infrastructure/05-02-SUMMARY.md`
</output>