---
phase: 05-backend-infrastructure
plan: 03
type: execute
wave: 3
depends_on: [05-02]
files_modified: [
  backend/cloudbuild.yaml,
  backend/.gcloudignore,
  backend/package.json,
  .github/workflows/deploy-backend.yml
]
autonomous: true

must_haves:
  truths:
    - "Backend deploys successfully to Cloud Run"
    - "Deployed service responds to health checks"
    - "API endpoints accessible via Cloud Run URL"
  artifacts:
    - path: "backend/cloudbuild.yaml"
      provides: "Cloud Build CI/CD configuration"
      contains: "gcr.io/cloud-builders/docker"
    - path: "backend/package.json"
      provides: "Build and start scripts"
      contains: "\"start\""
    - path: ".github/workflows/deploy-backend.yml"
      provides: "GitHub Actions deployment workflow"
      contains: "gcloud"
  key_links:
    - from: "backend/cloudbuild.yaml"
      to: "backend/Dockerfile"
      via: "docker build command"
      pattern: "docker.*build"
    - from: ".github/workflows/deploy-backend.yml"
      to: "Cloud Build"
      via: "gcloud builds submit"
      pattern: "gcloud.*builds.*submit"
    - from: "Cloud Run service"
      to: "backend/src/app.ts"
      via: "container deployment"
      pattern: "PORT.*process\\.env\\.PORT"
---

<objective>
Deploy backend to Cloud Run with automated CI/CD pipeline for production readiness.

Purpose: Make the backend API publicly accessible to the mobile app via Cloud Run deployment with automated deployment pipeline.
Output: Live Cloud Run service with public URL and CI/CD pipeline for future updates
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-backend-infrastructure/05-RESEARCH.md
@.planning/phases/05-backend-infrastructure/05-01-SUMMARY.md
@.planning/phases/05-backend-infrastructure/05-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure Cloud Build for Deployment</name>
  <files>
    backend/cloudbuild.yaml
    backend/package.json
  </files>
  <action>
    Create Cloud Build configuration following research deployment pattern:

    1. Create backend/cloudbuild.yaml with 3-step deployment:
       - Step 1: Build container using gcr.io/cloud-builders/docker
       - Step 2: Push to Container Registry (gcr.io/$PROJECT_ID/browsy-backend:$COMMIT_SHA)
       - Step 3: Deploy to Cloud Run with gcloud run deploy
       - Use research example configuration with us-central1 region, 1Gi memory, 1 CPU

    2. Update backend/package.json scripts:
       - Add "build": "tsc" for TypeScript compilation
       - Add "start": "node dist/app.js" for production startup
       - Ensure "dev" script exists for local development

    3. Configure Cloud Run deployment parameters:
       - Service name: browsy-backend
       - Allow unauthenticated access (mobile app needs public API)
       - Memory: 1Gi, CPU: 1 (research recommendations for Node.js + Firestore)
       - Platform: managed (serverless)

    Follow research cloudbuild.yaml pattern exactly for optimal Cloud Run deployment.
  </action>
  <verify>cd backend && npm run build</verify>
  <done>Cloud Build configuration exists and TypeScript compiles to dist/ directory</done>
</task>

<task type="auto">
  <name>Task 2: Deploy to Cloud Run</name>
  <files>
    backend/.gcloudignore
  </files>
  <action>
    Deploy backend to Cloud Run using gcloud CLI:

    1. Update backend/.gcloudignore for optimal deployment:
       - Exclude node_modules (rebuilt in Docker)
       - Exclude .git, .env, src/ (TypeScript source)
       - Include only dist/, package*.json, Dockerfile

    2. Build and deploy using gcloud commands:
       - gcloud builds submit --config cloudbuild.yaml
       - Verify deployment succeeds and note the service URL
       - Test health endpoint at https://SERVICE-URL/health

    3. Configure Cloud Run service settings:
       - Set environment variables (GOOGLE_CLOUD_PROJECT from metadata)
       - Configure service to use Google Default Credentials (no explicit key needed)
       - Verify logs show successful Firebase Admin initialization

    The service will be accessible at https://browsy-backend-[hash]-uc.a.run.app format.
  </action>
  <verify>gcloud run services describe browsy-backend --region=us-central1</verify>
  <done>Cloud Run service deployed successfully and health endpoint returns 200</done>
</task>

<task type="auto">
  <name>Task 3: Create CI/CD Pipeline</name>
  <files>
    .github/workflows/deploy-backend.yml
  </files>
  <action>
    Set up GitHub Actions workflow for automated backend deployment:

    1. Create .github/workflows/deploy-backend.yml with workflow:
       - Trigger on push to main branch in backend/ directory
       - Use google-github-actions/setup-gcloud action
       - Authenticate using workload identity or service account
       - Run gcloud builds submit with cloudbuild.yaml

    2. Configure workflow steps:
       - Checkout code
       - Setup gcloud CLI
       - Authenticate with GCP
       - Submit Cloud Build (only when backend/ files change)
       - Report deployment status

    3. Add path filtering to only trigger on backend changes:
       - paths: ['backend/**'] to avoid unnecessary deploys

    This enables automatic deployment when backend code changes are pushed to main.
    Note: Requires GCP service account key in GitHub secrets for authentication.
  </action>
  <verify>ls .github/workflows/deploy-backend.yml</verify>
  <done>CI/CD workflow file exists and configured for backend deployment automation</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Backend deployed to Cloud Run with public API endpoints</what-built>
  <how-to-verify>
    Test the deployed backend API:

    1. **Get Service URL:**
       ```bash
       gcloud run services describe browsy-backend --region=us-central1 --format="value(status.url)"
       ```

    2. **Test Health Endpoint:**
       ```bash
       curl [SERVICE-URL]/health
       ```
       Expected: {"status": "healthy", "timestamp": "..."}

    3. **Test API Endpoints:**
       ```bash
       # Get user shelves (should return empty array for new user)
       curl [SERVICE-URL]/api/shelves/test-user

       # Add a test book to TBR shelf
       curl -X POST [SERVICE-URL]/api/shelves/test-user/books \
         -H "Content-Type: application/json" \
         -d '{"shelfType": "TBR", "book": {"id": "test", "title": "Test Book", "author": "Test Author"}}'
       ```

    4. **Verify in GCP Console:**
       - Cloud Run → browsy-backend service shows "Receiving traffic"
       - Firestore → users collection should show test-user document after API calls

    The backend is ready for mobile app integration.
  </how-to-verify>
  <resume-signal>Type "verified" when all API endpoints respond correctly and Firestore data appears</resume-signal>
</task>

</tasks>

<verification>
- [ ] Cloud Build configuration builds and deploys successfully
- [ ] Cloud Run service accepts HTTP traffic on public URL
- [ ] API endpoints (/health, /api/shelves/*) respond with correct status codes
- [ ] Firestore stores data when API endpoints are called
- [ ] GitHub Actions workflow configured for automated deployments
- [ ] Mobile app can reach API endpoints via Cloud Run URL
</verification>

<success_criteria>
- Backend API publicly accessible via Cloud Run URL
- All REST endpoints respond correctly for shelf operations
- Firestore integration works in production Cloud Run environment
- CI/CD pipeline enables automated deployment of backend updates
- Infrastructure ready for mobile app backend integration in Phase 6
</success_criteria>

<output>
After completion, create `.planning/phases/05-backend-infrastructure/05-03-SUMMARY.md`
</output>